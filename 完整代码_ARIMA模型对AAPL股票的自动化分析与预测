"""
ARIMA模型对AAPL股票的自动化分析与预测（2021-2024年）
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error, mean_absolute_error
from pmdarima import auto_arima
import seaborn as sns
import requests
import matplotlib
import platform
from functools import lru_cache
from concurrent.futures import ThreadPoolExecutor
import os
import time
import glob
import shutil
import importlib

# 根据操作系统设置合适的字体
if platform.system() == 'Windows':
    matplotlib.rcParams['font.sans-serif'] = ['Microsoft YaHei']  # Windows系统
elif platform.system() == 'Darwin':  # macOS系统
    matplotlib.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'Heiti TC', 'PingFang HK']
else:  # Linux系统
    matplotlib.rcParams['font.sans-serif'] = ['DejaVu Sans']

matplotlib.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号

# 设置全局字体大小
plt.rcParams['font.size'] = 12
plt.rcParams['axes.titlesize'] = 14
plt.rcParams['axes.labelsize'] = 12
plt.rcParams['xtick.labelsize'] = 10
plt.rcParams['ytick.labelsize'] = 10

import warnings

warnings.filterwarnings('ignore')


class ARIMAAnalysis:
    """
    @description: ARIMA时间序列分析类
    """

    def __init__(self, symbol, api_key, base_path):
        """
        @param symbol: 股票代码
        @param api_key: API密钥
        @param base_path: 结果保存路径
        """
        self.base_path = base_path
        self.symbol = symbol

        # 创建保存结果的目录
        os.makedirs(base_path, exist_ok=True)

        # 获取数据并预处理
        start_time = time.time()
        self.data = self.get_stock_data(symbol, api_key)
        self.prepare_data()
        print(f"数据获取和预处理完成，耗时: {time.time() - start_time:.2f}秒")

    @lru_cache(maxsize=5)  # 缓存最近的5个请求结果
    def get_stock_data(self, symbol, api_key):
        """
        @description: 从FMP获取股票数据并缓存结果
        @param symbol: 股票代码
        @param api_key: API密钥
        @return: 股票数据DataFrame
        """
        base_url = f"https://financialmodelingprep.com/api/v3/historical-price-full/{symbol}"
        params = {
            "apikey": api_key,
            "from": "2021-01-01",  # 更新为2021年
            "to": "2024-12-31"     # 更新为2024年
        }

        try:
            response = requests.get(base_url, params=params, timeout=10)  # 添加超时设置
            if response.status_code == 200:
                data = response.json()
                df = pd.DataFrame(data['historical'])
                df['date'] = pd.to_datetime(df['date'])
                df = df.sort_values('date')

                # 检查数据是否完整
                if df.empty:
                    raise Exception(f"获取到的{symbol}数据为空")

                # 检查缺失值
                missing_values = df.isnull().sum()
                if missing_values.any():
                    print(f"警告: 数据中存在缺失值: {missing_values[missing_values > 0]}")
                    df = df.fillna(method='ffill')  # 使用前向填充处理缺失值

                return df
            else:
                raise Exception(f"API请求失败，状态码: {response.status_code}")
        except requests.exceptions.RequestException as e:
            raise Exception(f"网络请求错误: {e}")

    def prepare_data(self):
        """
        @description: 数据预处理和可视化
        """
        # 设置日期索引
        self.data.set_index('date', inplace=True)

        # 确保数据按日期排序
        self.data = self.data.sort_index()

        # 绘制原始数据图
        plt.figure(figsize=(12, 6))
        plt.plot(self.data.index, self.data['adjClose'],
                 label='调整后收盘价')
        plt.title(f'{self.symbol} 股票价格时间序列 (2021-2024)')  # 更新标题
        plt.xlabel('日期')
        plt.ylabel('价格 (USD)')
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/original_series.png', dpi=300)
        plt.close()

        # 计算差分
        self.diff_data = pd.DataFrame()
        self.diff_data['adjClose_diff'] = self.data['adjClose'].diff()
        self.diff_data = self.diff_data.dropna()

        # 绘制差分后的数据图
        plt.figure(figsize=(12, 6))
        plt.plot(self.diff_data.index, self.diff_data['adjClose_diff'],
                 label='一阶差分', color='orange')
        plt.title(f'{self.symbol} 股票价格一阶差分 (2021-2024)')  # 更新标题
        plt.xlabel('日期')
        plt.ylabel('差分值')
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/differenced_series.png', dpi=300)
        plt.close()

        # 计算二阶差分 - 增加对差分数据的分析
        self.diff2_data = pd.DataFrame()
        self.diff2_data['adjClose_diff2'] = self.diff_data['adjClose_diff'].diff()
        self.diff2_data = self.diff2_data.dropna()

        # 绘制二阶差分图
        plt.figure(figsize=(12, 6))
        plt.plot(self.diff2_data.index, self.diff2_data['adjClose_diff2'],
                 label='二阶差分', color='green')
        plt.title(f'{self.symbol} 股票价格二阶差分 (2021-2024)')  # 更新标题
        plt.xlabel('日期')
        plt.ylabel('差分值')
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/second_differenced_series.png', dpi=300)
        plt.close()

    def adf_test(self):
        """
        @description: 进行ADF检验并可视化
        @return: ADF检验结果DataFrame
        """
        # 原始数据的ADF检验
        result_original = adfuller(self.data['adjClose'].dropna())

        # 一阶差分数据的ADF检验
        result_diff = adfuller(self.diff_data['adjClose_diff'].dropna())

        # 二阶差分数据的ADF检验
        result_diff2 = adfuller(self.diff2_data['adjClose_diff2'].dropna())

        # 创建ADF检验结果图
        fig, ax = plt.subplots(figsize=(10, 6))
        results_df = pd.DataFrame({
            'Series': ['原始序列', '一阶差分', '二阶差分'],
            'ADF统计量': [result_original[0], result_diff[0], result_diff2[0]],
            'p值': [result_original[1], result_diff[1], result_diff2[1]],
            '临界值(1%)': [result_original[4]['1%'], result_diff[4]['1%'], result_diff2[4]['1%']],
            '临界值(5%)': [result_original[4]['5%'], result_diff[4]['5%'], result_diff2[4]['5%']],
            '临界值(10%)': [result_original[4]['10%'], result_diff[4]['10%'], result_diff2[4]['10%']]
        })

        # 绘制ADF检验结果柱状图
        bar_width = 0.25
        index = np.arange(3)

        plt.bar(index, results_df['ADF统计量'], bar_width,
                label='ADF统计量', color='skyblue')
        plt.bar(index + bar_width, results_df['临界值(5%)'], bar_width,
                label='5%临界值', color='lightcoral')
        plt.bar(index + 2 * bar_width, results_df['p值'], bar_width,
                label='p值', color='lightgreen')

        plt.xlabel('序列类型')
        plt.ylabel('值')
        plt.title('ADF检验结果 (2021-2024)')  # 更新标题
        plt.xticks(index + bar_width, results_df['Series'])
        plt.legend()
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/adf_test_results.png', dpi=300)
        plt.close()

        # 打印详细结果
        print("\nADF检验结果:")
        for i, series in enumerate(results_df['Series']):
            print(f"{series}:")
            print(f"  ADF统计量: {results_df['ADF统计量'][i]:.4f}")
            print(f"  p值: {results_df['p值'][i]:.4f}")
            print(f"  5%临界值: {results_df['临界值(5%)'][i]:.4f}")
            is_stationary = results_df['ADF统计量'][i] < results_df['临界值(5%)'][i]
            print(f"  平稳性: {'平稳' if is_stationary else '非平稳'}")
            print()

        # 保存详细结果
        results_df.to_csv(f'{self.base_path}/adf_test_results.csv')

        # 根据ADF检验结果确定最适合的差分阶数
        recommended_d = 0
        for i, statistic in enumerate(results_df['ADF统计量']):
            if statistic < results_df['临界值(5%)'][i]:
                recommended_d = i
                break

        print(f"推荐差分阶数 (d): {recommended_d}")

        # 保存差分阶数选择
        with open(f'{self.base_path}/recommended_d.txt', 'w') as f:
            f.write(f"推荐差分阶数 (d): {recommended_d}")

        return results_df, recommended_d

    def plot_acf_pacf(self, max_lags=40):
        """
        @description: 绘制ACF和PACF图
        @param max_lags: 最大滞后阶数
        """
        # 为每个序列创建ACF和PACF图
        series_data = [
            (self.data['adjClose'].dropna(), '原始序列'),
            (self.diff_data['adjClose_diff'], '一阶差分序列'),
            (self.diff2_data['adjClose_diff2'], '二阶差分序列')
        ]

        for series, name in series_data:
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

            # ACF
            plot_acf(series, ax=ax1, lags=max_lags, title=f'{name} - 自相关函数(ACF)')
            ax1.set_xlabel('滞后阶数')
            ax1.set_ylabel('自相关系数')
            ax1.grid(True, alpha=0.3)

            # PACF
            plot_pacf(series, ax=ax2, lags=max_lags, title=f'{name} - 偏自相关函数(PACF)')
            ax2.set_xlabel('滞后阶数')
            ax2.set_ylabel('偏自相关系数')
            ax2.grid(True, alpha=0.3)

            plt.tight_layout()
            plt.savefig(f'{self.base_path}/acf_pacf_{name}.png', dpi=300)
            plt.close()

        print("\nACF和PACF分析完成")

    def find_best_parameters(self, d=None):
        """
        @description: 使用auto_arima找到最优参数
        @param d: 可选的差分阶数，如果为None则由auto_arima自动确定
        @return: 最优ARIMA参数
        """
        start_time = time.time()
        print("开始使用auto_arima寻找最优参数...")

        # 选择差分序列
        if d is not None:
            if d == 1:
                series = self.diff_data['adjClose_diff']
            elif d == 2:
                series = self.diff2_data['adjClose_diff2']
            else:
                series = self.data['adjClose']
        else:
            series = self.data['adjClose']

        # 使用更精细的参数范围
        model = auto_arima(series,
                           start_p=0, start_q=0,
                           max_p=5, max_q=5,
                           d=d,  # 使用指定的差分阶数
                           m=1, start_P=0,
                           seasonal=False,
                           max_d=2 if d is None else d,
                           information_criterion='aic',  # 使用AIC而不是默认的AIC
                           trace=True,
                           error_action='ignore',
                           suppress_warnings=True,
                           stepwise=True)

        # 打印最优模型
        print(f"\n最优ARIMA参数: {model.order}")
        print(f"AIC: {model.aic():.4f}")
        print(f"搜索耗时: {time.time() - start_time:.2f}秒")

        # 保存最优参数
        params = pd.DataFrame({
            '参数': ['p', 'd', 'q'],
            '值': [model.order[0], model.order[1], model.order[2]]
        })
        params.to_csv(f'{self.base_path}/best_parameters.csv')

        return model.order

    def test_multiple_models(self, recommended_d=None):
        """
        @description: 测试不同的ARIMA参数组合，找到最优模型
        @param recommended_d: 推荐的差分阶数
        @return: 最佳模型参数
        """
        print("\n开始测试不同的ARIMA模型...")
        start_time = time.time()

        # 创建2024年6月1日的预测起点 (更新为2024年)
        start_date = '2024-06-01'
        forecast_start = pd.to_datetime(start_date)

        # 获取实际数据（7天）
        actual_7days = self.data['adjClose'][forecast_start:][:7]

        # 如果有推荐的差分阶数，添加更多针对该阶数的参数组合
        if recommended_d is not None:
            base_orders = [
                (1, recommended_d, 1),
                (1, recommended_d, 2),
                (2, recommended_d, 1),
                (2, recommended_d, 2),
                (3, recommended_d, 1),
                (2, recommended_d, 3)
            ]
        else:
            base_orders = [
                (1, 1, 1),
                (1, 1, 2),
                (2, 1, 1),
                (2, 1, 2),
                (1, 0, 1),
                (0, 1, 1)
            ]

        # 添加更多的组合以进行更全面的测试
        additional_orders = [
            (1, 2, 1),
            (2, 2, 1),
            (2, 0, 2),
            (3, 1, 2)
        ]

        orders = list(set(base_orders + additional_orders))  # 去除可能的重复

        results = []

        plt.figure(figsize=(15, 8))
        plt.plot(actual_7days.index, actual_7days, 'ko-', label='实际值', linewidth=2)

        colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown',
                  'pink', 'gray', 'cyan', 'magenta']

        # 并行处理不同模型
        def test_model(order):
            try:
                # 训练ARIMA模型
                model = ARIMA(self.data['adjClose'][:forecast_start], order=order)
                model_fit = model.fit()

                # 预测7天
                forecast = model_fit.forecast(steps=len(actual_7days))

                # 确保长度匹配
                min_length = min(len(actual_7days), len(forecast))
                actual_values = actual_7days[:min_length]
                forecast_values = forecast[:min_length]

                # 计算指标
                mse = mean_squared_error(actual_values, forecast_values)
                rmse = np.sqrt(mse)
                mae = mean_absolute_error(actual_values, forecast_values)

                # 安全计算MAPE
                mape_values = []
                for a, f in zip(actual_values, forecast_values):
                    if a != 0:
                        mape_values.append(abs((a - f) / a) * 100)

                if mape_values:
                    mape = np.mean(mape_values)
                else:
                    mape = float('nan')

                # 计算AIC和BIC
                aic = model_fit.aic
                bic = model_fit.bic

                # 返回结果
                return {
                    'Order': order,
                    'MSE': mse,
                    'RMSE': rmse,
                    'MAE': mae,
                    'MAPE': mape,
                    'AIC': aic,
                    'BIC': bic,
                    'Forecast': forecast_values
                }

            except Exception as e:
                print(f"ARIMA{order}模型出错: {e}")
                return None

        # 使用多线程处理多个模型
        with ThreadPoolExecutor(max_workers=min(4, len(orders))) as executor:
            model_results = list(executor.map(test_model, orders))

        # 过滤掉None结果
        model_results = [r for r in model_results if r is not None]

        # 将结果添加到列表
        results.extend(model_results)

        # 绘制预测结果
        for i, result in enumerate(results):
            plt.plot(actual_7days.index, result['Forecast'],
                     marker='o', linestyle='--',
                     color=colors[i % len(colors)],
                     label=f'ARIMA{result["Order"]} (MSE={result["MSE"]:.4f})')

        plt.title('不同ARIMA模型的7天预测比较 (2021-2024数据)')
        plt.xlabel('日期')
        plt.ylabel('股票价格 (USD)')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.xticks(rotation=45)
        plt.tight_layout()

        # 添加图片说明
        plt.figtext(0.5, 0.01,
                    "图: 不同ARIMA模型的7天股票价格预测比较",
                    ha="center", fontsize=10, bbox={"facecolor": "white", "alpha": 0.8, "pad": 5})

        plt.savefig(f'{self.base_path}/model_comparison_7days.png', dpi=300, bbox_inches='tight')
        plt.close()

        # 创建模型比较表格 - 使用综合指标进行排序
        df_results = pd.DataFrame(results)

        # 计算综合评分 (综合考虑MSE、AIC和BIC)
        # 对MSE、AIC和BIC进行归一化处理
        df_results['MSE_norm'] = (df_results['MSE'] - df_results['MSE'].min()) / (
                    df_results['MSE'].max() - df_results['MSE'].min() + 1e-10)
        df_results['AIC_norm'] = (df_results['AIC'] - df_results['AIC'].min()) / (
                    df_results['AIC'].max() - df_results['AIC'].min() + 1e-10)
        df_results['BIC_norm'] = (df_results['BIC'] - df_results['BIC'].min()) / (
                    df_results['BIC'].max() - df_results['BIC'].min() + 1e-10)

        # 综合评分 (较低的分数更好)
        df_results['Score'] = 0.5 * df_results['MSE_norm'] + 0.25 * df_results['AIC_norm'] + 0.25 * df_results[
            'BIC_norm']

        # 按评分排序
        df_results = df_results.sort_values('Score')

        # 移除辅助列
        df_results = df_results.drop(['MSE_norm', 'AIC_norm', 'BIC_norm', 'Forecast'], axis=1)

        df_results.to_csv(f'{self.base_path}/model_comparison_7days.csv', index=False)

        # 绘制模型比较热力图
        metrics_to_plot = ['MSE', 'RMSE', 'MAE', 'MAPE', 'AIC', 'BIC', 'Score']

        # 准备热力图数据
        heatmap_data = df_results[['Order'] + metrics_to_plot].copy()
        heatmap_data['Order'] = heatmap_data['Order'].astype(str)
        heatmap_data.set_index('Order', inplace=True)

        # 对每一列进行规范化处理，以便更好地在热力图中显示
        for col in heatmap_data.columns:
            if heatmap_data[col].max() > 0:
                heatmap_data[col] = (heatmap_data[col] - heatmap_data[col].min()) / (
                            heatmap_data[col].max() - heatmap_data[col].min() + 1e-10)

        plt.figure(figsize=(10, 8))
        sns.heatmap(heatmap_data, annot=True, cmap='YlGnBu', fmt='.2f')
        plt.title('ARIMA模型性能指标比较 (规范化值)')
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/model_metrics_heatmap.png', dpi=300)
        plt.close()

        # 绘制主要指标的柱状图
        primary_metrics = ['MSE', 'AIC', 'BIC']

        fig, axes = plt.subplots(len(primary_metrics), 1, figsize=(12, 10), sharex=True)

        top_5_models = df_results.head(5)

        for i, metric in enumerate(primary_metrics):
            ax = axes[i]
            bars = ax.bar(top_5_models['Order'].astype(str), top_5_models[metric], color='skyblue')

            # 添加数值标签
            for bar in bars:
                height = bar.get_height()
                ax.annotate(f'{height:.2f}',
                            xy=(bar.get_x() + bar.get_width() / 2, height),
                            xytext=(0, 3),  # 3 points vertical offset
                            textcoords="offset points",
                            ha='center', va='bottom')

            ax.set_title(f'{metric} 比较')
            ax.set_ylabel(metric)
            ax.grid(True, axis='y', alpha=0.3)

        plt.xlabel('ARIMA模型 (p,d,q)')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/top_models_metrics.png', dpi=300, bbox_inches='tight')
        plt.close()

        print("\n模型比较结果:")
        print(df_results.head())

        print(f"模型测试耗时: {time.time() - start_time:.2f}秒")

        # 返回最佳模型的参数 - 基于综合评分
        best_order = tuple(df_results.iloc[0]['Order'])
        print(f"\n最佳模型: ARIMA{best_order}")

        return best_order

    def forecast_and_evaluate(self, steps, order):
        """
        @description: 进行预测并评估
        @param steps: 预测步数
        @param order: ARIMA模型参数
        @return: 预测结果、置信区间和评估指标
        """
        print(f"\n开始进行{steps}天预测 (ARIMA{order})...")

        # 获取2024年6月1日之后的数据进行预测 (更新为2024年)
        start_date = '2024-06-01'
        forecast_start = pd.to_datetime(start_date)

        # 分割训练集和测试集
        train_data = self.data['adjClose'][:forecast_start]
        test_data = self.data['adjClose'][forecast_start:][:steps]

        # 训练模型
        model = ARIMA(train_data, order=order)
        model_fit = model.fit()

        # 预测
        forecast = model_fit.forecast(steps=steps)
        conf_int = model_fit.get_forecast(steps=steps).conf_int()

        # 确保长度匹配
        min_length = min(len(test_data), len(forecast))
        actual = test_data[:min_length]
        forecast = forecast[:min_length]
        conf_int = conf_int.iloc[:min_length]

        # 计算评估指标
        mse = mean_squared_error(actual, forecast)
        rmse = np.sqrt(mse)
        mae = mean_absolute_error(actual, forecast)

        # 安全计算MAPE
        mape_values = []
        for a, f in zip(actual, forecast):
            if a != 0:
                mape_values.append(abs((a - f) / a) * 100)

        if mape_values:
            mape = np.mean(mape_values)
        else:
            mape = float('nan')

        # 计算MASE (Mean Absolute Scaled Error)
        # MASE = MAE / MAE(naive forecast)
        if len(train_data) > 1:
            naive_errors = np.abs(np.diff(train_data))
            naive_mae = np.mean(naive_errors)
            mase = mae / naive_mae if naive_mae > 0 else float('nan')
        else:
            mase = float('nan')

        # 保存评估指标
        metrics = pd.DataFrame({
            '指标': ['MSE', 'RMSE', 'MAE', 'MAPE', 'MASE'],
            '值': [mse, rmse, mae, mape, mase]
        })

        # 打印评估指标
        print(f"\n{steps}天预测结果评估指标 (ARIMA{order}):")
        for i, metric in enumerate(metrics['指标']):
            print(f"{metric}: {metrics['值'][i]:.4f}" + ("%" if metric == "MAPE" else ""))

        metrics.to_csv(f'{self.base_path}/metrics_{steps}days.csv')

        # 保存预测结果
        results_df = pd.DataFrame(index=actual.index)
        results_df['Actual'] = actual
        results_df['Predicted'] = forecast
        if isinstance(conf_int, pd.DataFrame):
            results_df['Lower_CI'] = conf_int.iloc[:, 0].values
            results_df['Upper_CI'] = conf_int.iloc[:, 1].values
        results_df['Error'] = actual - forecast
        results_df['Absolute_Error'] = np.abs(actual - forecast)

        # 安全计算百分比误差
        pct_errors = []
        for a, f in zip(actual, forecast):
            if a != 0:
                pct_errors.append(abs((a - f) / a) * 100)
            else:
                pct_errors.append(np.nan)

        results_df['Percentage_Error'] = pct_errors
        results_df.to_csv(f'{self.base_path}/forecast_results_{steps}days.csv')

        # 绘制预测结果
        plt.figure(figsize=(12, 6))
        plt.plot(actual.index, actual, label='实际值', marker='o', color='blue')
        plt.plot(actual.index, forecast, label='预测值', linestyle='--', marker='s', color='red')

        if isinstance(conf_int, pd.DataFrame):
            plt.fill_between(actual.index,
                             conf_int.iloc[:, 0],
                             conf_int.iloc[:, 1],
                             color='gray', alpha=0.2,
                             label='95%置信区间')

        plt.title(f'{self.symbol} {steps}天股价预测 (ARIMA{order}) (2021-2024)')  # 更新标题
        plt.xlabel('日期')
        plt.ylabel('价格 (USD)')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.xticks(rotation=45)

        # 添加误差数据在图中
        error_text = (f"MSE: {mse:.4f}\nRMSE: {rmse:.4f}\nMAE: {mae:.4f}\nMAPE: {mape:.2f}%")

        plt.annotate(error_text, xy=(0.02, 0.02), xycoords='axes fraction',
                     bbox=dict(boxstyle="round,pad=0.5", fc="white", alpha=0.8))

        # 添加图片说明
        plt.figtext(0.5, 0.01,
                    f"图: {steps}天股价使用ARIMA{order}模型的预测结果",
                    ha="center", fontsize=10, bbox={"facecolor": "white", "alpha": 0.8, "pad": 5})

        plt.tight_layout()
        plt.savefig(f'{self.base_path}/forecast_{steps}days.png', dpi=300, bbox_inches='tight')
        plt.close()

        # 绘制评估指标图 - 包含所有四个误差指标
        plt.figure(figsize=(12, 7))
        error_metrics = metrics[metrics['指标'].isin(['MSE', 'RMSE', 'MAE', 'MAPE'])]
        colors = ['skyblue', 'lightgreen', 'lightcoral', 'orange']

        # 创建两个子图，左边放MSE/RMSE/MAE，右边放MAPE（因为单位不同）
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6), gridspec_kw={'width_ratios': [3, 1]})

        # 左边子图 - MSE/RMSE/MAE
        first_three = error_metrics[error_metrics['指标'].isin(['MSE', 'RMSE', 'MAE'])]
        bars1 = ax1.bar(first_three['指标'], pd.to_numeric(first_three['值'], errors='coerce'), color=colors[:3])

        # 在柱状图上添加具体数值
        for bar in bars1:
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width() / 2., height + 0.01,
                     f'{height:.4f}',
                     ha='center', va='bottom')

        ax1.set_title(f'误差指标 (MSE/RMSE/MAE)')
        ax1.set_xlabel('指标')
        ax1.set_ylabel('值')
        ax1.grid(True, axis='y', alpha=0.3)

        # 右边子图 - MAPE
        mape_data = error_metrics[error_metrics['指标'] == 'MAPE']
        bars2 = ax2.bar(mape_data['指标'], pd.to_numeric(mape_data['值'], errors='coerce'), color=colors[3])

        # 在柱状图上添加具体数值
        for bar in bars2:
            height = bar.get_height()
            ax2.text(bar.get_x() + bar.get_width() / 2., height + 0.01,
                     f'{height:.2f}%',
                     ha='center', va='bottom')

        # 添加10%MAPE目标线
        ax2.axhline(y=10, color='black', linestyle='--', label='10% MAPE目标线')
        ax2.legend()

        ax2.set_title(f'误差指标 (MAPE)')
        ax2.set_xlabel('指标')
        ax2.set_ylabel('百分比 (%)')
        ax2.grid(True, axis='y', alpha=0.3)

        plt.suptitle(f'{steps}天预测的误差评估指标 (ARIMA{order})')

        # 添加图片说明
        plt.figtext(0.5, 0.01,
                    f"图: {steps}天ARIMA{order}模型预测的误差指标",
                    ha="center", fontsize=10, bbox={"facecolor": "white", "alpha": 0.8, "pad": 5})

        plt.tight_layout()
        plt.savefig(f'{self.base_path}/error_metrics_{steps}days.png', dpi=300, bbox_inches='tight')
        plt.close()

        # 残差分析
        self.residual_analysis(model_fit, steps, order)

        return forecast, conf_int, metrics

    def plot_metrics(self, metrics, steps, order):
        """
        绘制评估指标图
        """
        plt.figure(figsize=(10, 6))
        colors = ['skyblue', 'lightgreen', 'lightcoral', 'orange']

        bars = plt.bar(metrics['指标'], metrics['值'], color=colors)

        plt.title(f'Forecast Evaluation Metrics ({steps}-Day Forecast) for ARIMA{order}')
        plt.xlabel('Metric')
        plt.ylabel('Value')
        plt.grid(True, axis='y')

        # 在柱状图上添加具体数值
        for bar in bars:
            height = bar.get_height()
            plt.text(bar.get_x() + bar.get_width() / 2., height,
                     f'{height:.2f}',
                     ha='center', va='bottom')

        plt.tight_layout()
        plt.savefig(f'{self.base_path}/metrics_{steps}days.png', dpi=300)
        plt.close()

    def residual_analysis(self, model_fit, steps, order):
        """
        残差分析
        """
        residuals = model_fit.resid

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))

        # 残差时间序列图
        residuals.plot(ax=ax1)
        ax1.set_title('Residuals Time Series')
        ax1.set_xlabel('Date')
        ax1.set_ylabel('Residual')

        # 残差直方图
        sns.histplot(residuals, ax=ax2, kde=True)
        ax2.set_title('Residuals Distribution')
        ax2.set_xlabel('Residual')
        ax2.set_ylabel('Frequency')

        # 残差QQ图
        from scipy import stats
        stats.probplot(residuals, dist="norm", plot=ax3)
        ax3.set_title('Residuals Q-Q Plot')

        # 残差自相关图
        plot_acf(residuals, ax=ax4)
        ax4.set_title('Residuals ACF')

        plt.suptitle(f'Residual Analysis for {steps}-Day Forecast (ARIMA{order})', y=1.02)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/residuals_analysis_{steps}days.png', dpi=300)
        plt.close()

    def set_plot_chinese(self):
        """
        设置图表中文显示
        """
        try:
            # 尝试设置中文字体
            plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'Heiti TC', 'PingFang HK',
                                               'Microsoft YaHei', 'SimHei', 'DejaVu Sans']
        except:
            # 如果设置失败，使用英文标签
            self.use_english = True
            print("警告：中文字体设置失败，使用英文标签")

    def get_title(self, chinese_text, english_text):
        """
        根据字体支持情况返回适当的标题
        """
        return english_text if hasattr(self, 'use_english') else chinese_text

    def generate_report(self, best_order, forecasts_results=None):
        """
        @description: 生成详细的分析报告
        @param best_order: 最佳ARIMA模型参数
        @param forecasts_results: 不同时间窗口的预测结果字典 {steps: (forecast, conf_int, metrics)}
        """
        print("\n开始生成分析报告...")

        # 创建报告目录
        report_dir = f"{self.base_path}/report"
        os.makedirs(report_dir, exist_ok=True)

        # 报告文件路径
        report_file = f"{report_dir}/{self.symbol}_ARIMA_Report.html"
        pdf_file = f"{report_dir}/{self.symbol}_ARIMA_Report.pdf"

        # 复制所有图片到报告目录
        image_files = glob.glob(f"{self.base_path}/*.png")
        for img_file in image_files:
            img_name = os.path.basename(img_file)
            shutil.copy(img_file, f"{report_dir}/{img_name}")

        # HTML报告内容
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>{self.symbol} ARIMA分析报告</title>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    line-height: 1.6;
                    margin: 0;
                    padding: 20px;
                    color: #333;
                }}
                .container {{
                    max-width: 1200px;
                    margin: 0 auto;
                }}
                h1, h2, h3 {{
                    color: #2c3e50;
                }}
                h1 {{
                    text-align: center;
                    border-bottom: 2px solid #3498db;
                    padding-bottom: 10px;
                }}
                h2 {{
                    border-bottom: 1px solid #ddd;
                    padding-bottom: 5px;
                    margin-top: 30px;
                }}
                .section {{
                    margin: 30px 0;
                }}
                .image-container {{
                    text-align: center;
                    margin: a20px 0;
                }}
                img {{
                    max-width: 100%;
                    height: auto;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                }}
                table {{
                    width: 100%;
                    border-collapse: collapse;
                    margin: 20px 0;
                }}
                th, td {{
                    padding: 10px;
                    border: 1px solid #ddd;
                    text-align: left;
                }}
                th {{
                    background-color: #f2f2f2;
                }}
                tr:nth-child(even) {{
                    background-color: #f9f9f9;
                }}
                .conclusion {{
                    background-color: #f8f9fa;
                    padding: 15px;
                    border-left: 4px solid #3498db;
                    margin: 20px 0;
                }}
                .footer {{
                    text-align: center;
                    margin-top: 40px;
                    font-size: 0.9em;
                    color: #777;
                    border-top: 1px solid #ddd;
                    padding-top: 20px;
                }}
                .explanation {{
                    background-color: #f1f9f1;
                    padding: 10px;
                    border-radius: 5px;
                    margin: 10px 0;
                    font-size: 0.9em;
                }}
                .model-info {{
                    background-color: #e8f4fc;
                    padding: 15px;
                    border-radius: 5px;
                    margin: 15px 0;
                }}
                .chart-description {{
                    font-style: italic;
                    color: #555;
                    margin: 5px 0 15px 0;
                }}
                @page {{
                    margin: 1cm;
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>{self.symbol} 股票 ARIMA 模型分析报告</h1>

                <div class="section">
                    <h2>1. 数据概览</h2>
                    <p>本报告分析了{self.symbol}股票从{self.data.index[0].strftime('%Y年%m月%d日')}至{self.data.index[-1].strftime('%Y年%m月%d日')}的历史数据。</p>
                    <p>数据点总数: {len(self.data)}</p>
                    <p>股价范围: ${self.data['adjClose'].min():.2f} - ${self.data['adjClose'].max():.2f}</p>
                    <p>平均股价: ${self.data['adjClose'].mean():.2f}</p>
                    <p>标准差: ${self.data['adjClose'].std():.2f}</p>
                    <p>交易日数量: {len(self.data)}</p>

                    <div class="model-info">
                        <h3>ARIMA模型简介</h3>
                        <p>ARIMA(自回归综合移动平均)模型是一种用于时间序列预测的统计模型，由三个部分组成：</p>
                        <ul>
                            <li><strong>AR(p)</strong>: 自回归部分，使用过去p个时间点的值来预测</li>
                            <li><strong>I(d)</strong>: 综合部分，表示需要进行d次差分才能使序列平稳</li>
                            <li><strong>MA(q)</strong>: 移动平均部分，使用过去q个预测误差来改进预测</li>
                        </ul>
                    </div>

                    <div class="image-container">
                        <img src="original_series.png" alt="原始股价时间序列">
                        <p>图1: {self.symbol}股票价格时间序列</p>
                        <div class="chart-description">
                            此图展示了原始股价的变动趋势，可用于观察长期趋势、季节性和周期性模式，以及异常波动。
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2>2. 平稳性分析</h2>
                    <div class="explanation">
                        <p><strong>为什么需要平稳性?</strong> ARIMA模型要求时间序列数据具有平稳性(即统计特性不随时间变化)。平稳的时间序列具有恒定的均值、方差和自相关结构，这使得模型能够更准确地捕捉数据的内在模式。</p>
                    </div>

                    <p>时间序列分析要求数据具有平稳性。以下是原始序列和差分序列的分析:</p>

                    <div class="image-container">
                        <img src="differenced_series.png" alt="一阶差分序列">
                        <p>图2: {self.symbol}股票价格一阶差分</p>
                        <div class="chart-description">
                            一阶差分序列表示相邻时间点之间的变化。平稳的差分序列应该在零附近波动，没有明显的趋势。
                        </div>
                    </div>

                    <div class="image-container">
                        <img src="adf_test_results.png" alt="ADF检验结果">
                        <p>图3: ADF检验结果</p>
                        <div class="chart-description">
                            增广迪基-富勒(ADF)检验是评估时间序列平稳性的统计检验。p值小于0.05表示序列是平稳的。
                        </div>
                    </div>

                    <h3>ADF检验结果</h3>
                    <table>
                        <tr>
                            <th>序列</th>
                            <th>ADF统计量</th>
                            <th>p值</th>
                            <th>5%临界值</th>
                            <th>平稳性</th>
                        </tr>
        """

        # 读取ADF检验结果
        try:
            adf_results = pd.read_csv(f"{self.base_path}/adf_test_results.csv")
            for i, row in adf_results.iterrows():
                is_stationary = row['ADF统计量'] < row['临界值(5%)']
                html_content += f"""
                <tr>
                    <td>{row['Series']}</td>
                    <td>{row['ADF统计量']:.4f}</td>
                    <td>{row['p值']:.4f}</td>
                    <td>{row['临界值(5%)']:.4f}</td>
                    <td>{'平稳' if is_stationary else '非平稳'}</td>
                </tr>
                """
        except:
            html_content += "<tr><td colspan='5'>无法加载ADF检验结果</td></tr>"

        html_content += """
                    </table>
                    <div class="explanation">
                        <p><strong>如何解读ADF检验结果:</strong></p>
                        <ul>
                            <li>p值 < 0.05: 拒绝原假设，序列是平稳的</li>
                            <li>ADF统计量 < 临界值: 序列是平稳的</li>
                            <li>如果原始序列不平稳，我们通过差分使其平稳</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2>3. ACF和PACF分析</h2>
                    <div class="explanation">
                        <p><strong>ACF和PACF的作用:</strong> 自相关函数(ACF)和偏自相关函数(PACF)图用于确定ARIMA模型的p和q参数:</p>
                        <ul>
                            <li>ACF: 显示时间序列与其滞后值之间的相关性</li>
                            <li>PACF: 显示时间序列与其滞后值之间的直接相关性(排除中间滞后的影响)</li>
                            <li>p: PACF显著截尾的滞后阶数</li>
                            <li>q: ACF显著截尾的滞后阶数</li>
                        </ul>
                    </div>

                    <div class="image-container">
                        <img src="acf_pacf_一阶差分序列.png" alt="一阶差分序列的ACF和PACF">
                        <p>图4: 一阶差分序列的ACF和PACF图</p>
                        <div class="chart-description">
                            蓝色阴影区域表示95%置信区间。超出此区域的柱状表示在该滞后处存在显著的相关性。
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2>4. 模型选择</h2>
        """

        # 读取模型比较结果
        try:
            models_results = pd.read_csv(f"{self.base_path}/model_comparison_7days.csv")
            html_content += f"""
                    <p>共测试了{len(models_results)}个不同的ARIMA模型参数组合。选择最佳模型的标准是MAPE值低于10%且MSE最小。</p>

                    <div class="explanation">
                        <p><strong>评估指标说明:</strong></p>
                        <ul>
                            <li><strong>MAPE(平均绝对百分比误差):</strong> 预测误差占实际值的百分比，越低越好</li>
                            <li><strong>MSE(均方误差):</strong> 预测值与实际值差值的平方的平均值，越低越好</li>
                            <li><strong>RMSE(均方根误差):</strong> MSE的平方根，与原始数据单位相同，越低越好</li>
                            <li><strong>MAE(平均绝对误差):</strong> 预测值与实际值绝对差值的平均值，越低越好</li>
                            <li><strong>AIC(赤池信息准则):</strong> 衡量模型质量的指标，考虑了拟合优度和复杂度，越低越好</li>
                            <li><strong>BIC(贝叶斯信息准则):</strong> 类似AIC但对模型复杂度惩罚更严格，越低越好</li>
                        </ul>
                    </div>

                    <div class="image-container">
                        <img src="model_metrics_heatmap.png" alt="模型性能热力图">
                        <p>图5: ARIMA模型性能指标比较 (规范化值)</p>
                        <div class="chart-description">
                            热力图中颜色越深表示性能越好。这有助于直观地比较不同模型在多个评估指标上的表现。
                        </div>
                    </div>

                    <div class="image-container">
                        <img src="model_mape_comparison.png" alt="MAPE比较">
                        <p>图6: 各ARIMA模型的MAPE比较</p>
                        <div class="chart-description">
                            MAPE（平均绝对百分比误差）是评估预测准确性的关键指标，该图展示了不同模型的MAPE值比较。
                        </div>
                    </div>

                    <h3>前5个表现最好的模型</h3>
                    <table>
                        <tr>
                            <th>模型</th>
                            <th>MAPE (%)</th>
                            <th>MSE</th>
                            <th>RMSE</th>
                            <th>MAE</th>
                            <th>AIC</th>
                            <th>BIC</th>
                        </tr>
            """

            # 按MAPE和MSE排序
            low_mape_models = models_results[models_results['MAPE'] < 10].sort_values('MSE')
            if len(low_mape_models) > 0:
                display_models = low_mape_models.head(5)
                best_model_note = "MAPE < 10%且MSE最小"
            else:
                display_models = models_results.sort_values('MAPE').head(5)
                best_model_note = "MAPE最小"

            for i, row in display_models.iterrows():
                order_str = str(tuple(row['Order'])) if isinstance(row['Order'], (list, tuple)) else row['Order']
                html_content += f"""
                <tr>
                    <td>ARIMA{order_str}</td>
                    <td>{row['MAPE']:.2f}</td>
                    <td>{row['MSE']:.4f}</td>
                    <td>{row['RMSE']:.4f}</td>
                    <td>{row['MAE']:.4f}</td>
                    <td>{row['AIC']:.2f}</td>
                    <td>{row['BIC']:.2f}</td>
                </tr>
                """

            html_content += f"""
                    </table>

                    <div class="model-info">
                        <p><strong>最佳模型:</strong> ARIMA{best_order} (选择标准: {best_model_note})</p>
                        <p><strong>模型解释:</strong> ARIMA{best_order} 表示:</p>
                        <ul>
                            <li>p = {best_order[0]}: 自回归项的阶数，表示模型使用过去{best_order[0]}个时间点的值</li>
                            <li>d = {best_order[1]}: 差分阶数，表示需要进行{best_order[1]}次差分使序列平稳</li>
                            <li>q = {best_order[2]}: 移动平均项的阶数，表示模型使用过去{best_order[2]}个预测误差</li>
                        </ul>
                    </div>
            """
        except:
            html_content += "<p>无法加载模型比较结果</p>"

        html_content += """
                </div>

                <div class="section">
                    <h2>5. 预测结果</h2>
        """

        # 添加不同时间窗口的预测结果
        if forecasts_results:
            for steps, (forecast, conf_int, metrics) in forecasts_results.items():
                html_content += f"""
                    <h3>{steps}天预测</h3>
                    <div class="image-container">
                        <img src="forecast_{steps}days.png" alt="{steps}天预测">
                        <p>图{6 + len(forecasts_results)}: {steps}天预测结果</p>
                        <div class="chart-description">
                            图中蓝色线表示历史数据，红色线表示预测值，红色阴影区域表示预测的95%置信区间。
                            置信区间越宽，预测的不确定性越大。
                        </div>
                    </div>

                    <h4>预测精度评估指标</h4>
                    <table>
                        <tr>
                            <th>指标</th>
                            <th>值</th>
                            <th>说明</th>
                        </tr>
                """

                # 解释评估指标
                metrics_explanations = {
                    'MSE': '平均平方误差 - 预测值与实际值差的平方的平均值',
                    'RMSE': '均方根误差 - MSE的平方根，与原始数据的量纲相同',
                    'MAE': '平均绝对误差 - 预测值与实际值的绝对差的平均值',
                    'MAPE': '平均绝对百分比误差 - 相对误差的平均值',
                    'MASE': '平均绝对缩放误差 - 相对于简单预测方法的MAE'
                }

                for i, row in metrics.iterrows():
                    metric = row['指标']
                    value = row['值']
                    explanation = metrics_explanations.get(metric, '')
                    suffix = '%' if metric == 'MAPE' else ''
                    html_content += f"""
                    <tr>
                        <td>{metric}</td>
                        <td>{value:.4f}{suffix}</td>
                        <td>{explanation}</td>
                    </tr>
                    """

                html_content += """
                    </table>
                """
        else:
            # 如果没有传入预测结果，尝试从文件加载
            for steps in [3, 7, 30]:
                try:
                    metrics = pd.read_csv(f"{self.base_path}/metrics_{steps}days.csv")
                    html_content += f"""
                        <h3>{steps}天预测</h3>
                        <div class="image-container">
                            <img src="forecast_{steps}days.png" alt="{steps}天预测">
                            <p>图{6 + (steps // 3)}: {steps}天预测结果</p>
                            <div class="chart-description">
                                图中蓝色线表示历史数据，红色线表示预测值，红色阴影区域表示预测的95%置信区间。
                            </div>
                        </div>

                        <h4>预测精度评估指标</h4>
                        <table>
                            <tr>
                                <th>指标</th>
                                <th>值</th>
                                <th>说明</th>
                            </tr>
                    """

                    # 解释评估指标
                    metrics_explanations = {
                        'MSE': '平均平方误差 - 预测值与实际值差的平方的平均值',
                        'RMSE': '均方根误差 - MSE的平方根，与原始数据的量纲相同',
                        'MAE': '平均绝对误差 - 预测值与实际值的绝对差的平均值',
                        'MAPE': '平均绝对百分比误差 - 相对误差的平均值',
                        'MASE': '平均绝对缩放误差 - 相对于简单预测方法的MAE'
                    }

                    for i, row in metrics.iterrows():
                        suffix = '%' if row['指标'] == 'MAPE' else ''
                        explanation = metrics_explanations.get(row['指标'], '')
                        html_content += f"""
                        <tr>
                            <td>{row['指标']}</td>
                            <td>{row['值']:.4f}{suffix}</td>
                            <td>{explanation}</td>
                        </tr>
                        """

                    html_content += """
                        </table>
                    """
                except:
                    html_content += f"<p>没有找到{steps}天预测的结果</p>"

        # 添加残差分析结果
        html_content += """
                <h3>残差分析</h3>
                <div class="image-container">
                    <img src="residuals_analysis_7days.png" alt="残差分析">
                    <p>图10: 模型残差分析</p>
                    <div class="chart-description">
                        残差分析用于评估模型拟合的充分性。理想情况下，残差应该呈现白噪声特性：均值为零，方差恒定，各观测值之间相互独立。
                    </div>
                </div>
                <div class="explanation">
                    <p><strong>残差分析解读:</strong></p>
                    <ul>
                        <li>QQ图: 评估残差是否服从正态分布，点越接近直线表示越符合正态分布</li>
                        <li>残差自相关: 检验残差之间是否存在相关性，如果大部分值在置信区间内，说明残差是独立的</li>
                        <li>残差分布: 应该近似正态分布，且均值接近于0</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h2>6. 结论</h2>
                <div class="conclusion">
                    <p>基于对{self.symbol}股票历史数据的ARIMA模型分析，我们得出以下结论:</p>
                    <p>1. 数据平稳性: 原始股价序列不满足平稳性条件，需要进行差分处理。一阶差分后的序列满足平稳性要求。</p>
                    <p>2. 最优模型: ARIMA{best_order}模型在多个评估指标上表现最佳。</p>
        """

        # 尝试读取3天和7天预测的MAPE
        mape_3d, mape_7d, mape_30d = None, None, None

        try:
            metrics_3d = pd.read_csv(f"{self.base_path}/metrics_3days.csv")
            mape_3d = metrics_3d[metrics_3d['指标'] == 'MAPE']['值'].values[0]
        except:
            pass

        try:
            metrics_7d = pd.read_csv(f"{self.base_path}/metrics_7days.csv")
            mape_7d = metrics_7d[metrics_7d['指标'] == 'MAPE']['值'].values[0]
        except:
            pass

        try:
            metrics_30d = pd.read_csv(f"{self.base_path}/metrics_30days.csv")
            mape_30d = metrics_30d[metrics_30d['指标'] == 'MAPE']['值'].values[0]
        except:
            pass

        # 添加预测精度结论
        if mape_3d is not None:
            html_content += f"<p>3. 短期预测(3天)精度: MAPE = {mape_3d:.2f}%"
            html_content += " (优秀)" if mape_3d < 10 else " (可接受)" if mape_3d < 20 else " (较差)"
            html_content += "</p>"

        if mape_7d is not None:
            html_content += f"<p>4. 中期预测(7天)精度: MAPE = {mape_7d:.2f}%"
            html_content += " (优秀)" if mape_7d < 10 else " (可接受)" if mape_7d < 20 else " (较差)"
            html_content += "</p>"

        if mape_30d is not None:
            html_content += f"<p>5. 长期预测(30天)精度: MAPE = {mape_30d:.2f}%"
            html_content += " (优秀)" if mape_30d < 10 else " (可接受)" if mape_30d < 20 else " (较差)"
            html_content += "</p>"

        # 总体评价和建议
        overall_rating = ""
        if mape_7d is not None:
            if mape_7d < 10:
                overall_rating = "模型预测精度较高，适合用于短期和中期的股价预测。"
            elif mape_7d < 20:
                overall_rating = "模型预测精度一般，可用于短期的股价走势参考，但中长期预测应谨慎使用。"
            else:
                overall_rating = "模型预测精度较低，建议结合其他技术指标和基本面分析进行投资决策。"

        html_content += f"""
                    <p>6. 总体评价: {overall_rating}</p>
                    <p>7. 模型应用建议:</p>
                    <ul>
                        <li>短期预测: 可以作为交易决策的参考之一</li>
                        <li>中长期预测: 应结合更多因素，如宏观经济指标、公司基本面和市场情绪</li>
                        <li>模型局限性: ARIMA模型主要捕捉线性关系，可能无法充分反映市场的非线性动态</li>
                    </ul>
                    <p>8. 未来改进方向:</p>
                    <ul>
                        <li>考虑结合机器学习模型如LSTM或GRU以捕捉非线性关系</li>
                        <li>加入更多特征如交易量、市场指数等提高预测精度</li>
                        <li>尝试集成多个模型的预测结果以提高稳定性</li>
                    </ul>
                </div>
            </div>

            <div class="footer">
                <p>本报告由ARIMA分析工具自动生成 | 生成日期: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                <p>© 2024 ARIMA股票分析系统</p>
            </div>
        </div>
        </body>
        </html>
        """

        # 写入HTML文件
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

        print(f"HTML分析报告已生成：{report_file}")

        # 将HTML转换为PDF
        try:
            # 尝试导入必要的模块
            weasyprint_spec = importlib.util.find_spec("weasyprint")

            if weasyprint_spec is None:
                print("未安装weasyprint库，无法生成PDF报告。请运行: pip install weasyprint")
                return report_file

            # WeasyPrint模块已安装，可以导入
            try:
                from weasyprint import HTML
                import tempfile

                # 创建临时HTML文件（解决相对路径问题）
                temp_dir = tempfile.mkdtemp()
                temp_html = os.path.join(temp_dir, "temp_report.html")

                # 修改HTML中的图片路径为绝对路径
                updated_html = html_content.replace('src="', f'src="{report_dir}/')

                with open(temp_html, 'w', encoding='utf-8') as f:
                    f.write(updated_html)

                try:
                    # 生成PDF
                    HTML(temp_html).write_pdf(pdf_file)
                    print(f"PDF分析报告已生成：{pdf_file}")
                except Exception as e:
                    print(f"生成PDF失败: {str(e)}")
                    print("原因可能是缺少系统级依赖，如Pango、Cairo等。")
                    print("在macOS上，您可以通过Homebrew安装这些依赖: brew install pango cairo")
                    print("请参考WeasyPrint文档: https://doc.courtbouillon.org/weasyprint/stable/first_steps.html")
                    print("将只生成HTML报告。")
                    return report_file
                finally:
                    # 清理临时文件
                    try:
                        os.remove(temp_html)
                        os.rmdir(temp_dir)
                    except:
                        pass
            except ImportError as e:
                print(f"导入WeasyPrint模块时出错: {str(e)}")
                print("将只生成HTML报告。")
                return report_file
        except Exception as e:
            print(f"生成PDF报告时出错: {str(e)}")
            print("将只生成HTML报告。")

        return report_file


def main():
    """
    主函数
    """
    base_path = '/Users/quyou/Desktop/毕业设计/ARIMA应用方向/AAPL_2021_2024'
    api_key = "qhylk6wN8OUWTgmLddldoMRPCo59NmBU"  # 请确保使用有效的API密钥
    symbol = "AAPL"

    try:
        # 创建分析对象
        analysis = ARIMAAnalysis(symbol, api_key, base_path)
        print("数据获取和预处理完成")

        # ADF检验
        adf_results, recommended_d = analysis.adf_test()
        print("\nADF检验结果:")
        print(adf_results)

        # 确保差分阶数至少为1
        if recommended_d < 1:
            print("ADF检验推荐的差分阶数小于1，强制使用d=1")
            recommended_d = 1

        # 绘制ACF和PACF图
        analysis.plot_acf_pacf()
        print("\nACF和PACF分析完成")

        # 比较不同的ARIMA模型
        print("\n开始测试不同的ARIMA模型...")
        best_order = analysis.test_multiple_models(recommended_d)

        # 存储各时间窗口的预测结果
        forecasts_results = {}

        # 对不同时间窗口进行预测
        for steps in [3, 7, 30]:
            forecast, conf_int, metrics = analysis.forecast_and_evaluate(steps, best_order)
            forecasts_results[steps] = (forecast, conf_int, metrics)

            # 检查MAPE是否低于10%
            mape_value = metrics[metrics['指标'] == 'MAPE']['值'].values[0]

            # 如果MAPE仍然大于10%，尝试其他模型
            if mape_value > 10:
                print(f"\n{steps}天预测的MAPE > 10%，尝试其他模型参数组合...")

                # 测试一些额外的模型，特别是针对当前时间窗口的（确保d至少为1）
                additional_orders = [
                    (4, max(1, recommended_d), 2),
                    (4, max(1, recommended_d), 3),
                    (5, max(1, recommended_d), 2),
                    (3, max(1, recommended_d), 4),
                    (2, max(1, recommended_d + 1), 2),
                    (3, max(1, recommended_d + 1), 1)
                ]

                best_mape = mape_value
                best_alternative_order = best_order

                for order in additional_orders:
                    try:
                        print(f"测试ARIMA{order}...")
                        model = ARIMA(analysis.data['adjClose'][:pd.to_datetime('2024-06-01')], order=order)  # 更新为2024年
                        model_fit = model.fit()

                        # 预测
                        alt_forecast = model_fit.forecast(steps=steps)

                        # 计算MAPE
                        actual = analysis.data['adjClose'][pd.to_datetime('2024-06-01'):][:steps]  # 更新为2024年
                        min_length = min(len(actual), len(alt_forecast))
                        actual = actual[:min_length]
                        alt_forecast = alt_forecast[:min_length]

                        alt_mape_values = []
                        for a, f in zip(actual, alt_forecast):
                            if a != 0:
                                alt_mape_values.append(abs((a - f) / a) * 100)

                        if alt_mape_values:
                            alt_mape = np.mean(alt_mape_values)
                            print(f"ARIMA{order} MAPE: {alt_mape:.2f}%")

                            if alt_mape < best_mape:
                                best_mape = alt_mape
                                best_alternative_order = order

                                # 如果找到MAPE < 10%的模型，立即使用
                                if alt_mape < 10:
                                    print(f"找到MAPE < 10%的模型: ARIMA{order} (MAPE: {alt_mape:.2f}%)")
                                    break

                    except Exception as e:
                        print(f"测试ARIMA{order}失败: {e}")

                # 如果找到更好的模型，使用它
                if best_alternative_order != best_order:
                    print(f"\n对于{steps}天预测，发现更好的模型: ARIMA{best_alternative_order} (MAPE: {best_mape:.2f}%)")
                    forecast, conf_int, metrics = analysis.forecast_and_evaluate(steps, best_alternative_order)
                    forecasts_results[steps] = (forecast, conf_int, metrics)

        # 生成综合分析报告
        report_file = analysis.generate_report(best_order, forecasts_results)
        print(f"\n分析已完成，详细报告已保存至: {report_file}")

    except Exception as e:
        print(f"发生错误: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main() 

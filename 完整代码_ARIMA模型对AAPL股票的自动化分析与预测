"""
ARIMA模型对AAPL股票的自动化分析与预测（2021-2024年）
此代码使用ARIMA模型分析AAPL股票的价格时间序列，包含数据获取、平稳性分析、模型选择、预测和报告生成功能。
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error, mean_absolute_error
from pmdarima import auto_arima
import seaborn as sns
import requests
import matplotlib
import platform
from functools import lru_cache
from concurrent.futures import ThreadPoolExecutor
import os
import time
import glob
import shutil
import importlib
from scipy import stats
from statsmodels.stats.stattools import durbin_watson
import statsmodels.api as sm
from statsmodels.tsa.stattools import acf

# 根据操作系统设置合适的字体
if platform.system() == 'Windows':
    matplotlib.rcParams['font.sans-serif'] = ['Microsoft YaHei']
elif platform.system() == 'Darwin':
    matplotlib.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'Heiti TC', 'PingFang HK']
else:
    matplotlib.rcParams['font.sans-serif'] = ['DejaVu Sans']

matplotlib.rcParams['axes.unicode_minus'] = False
plt.rcParams['font.size'] = 12
plt.rcParams['axes.titlesize'] = 14
plt.rcParams['axes.labelsize'] = 12
plt.rcParams['xtick.labelsize'] = 10
plt.rcParams['ytick.labelsize'] = 10

import warnings
warnings.filterwarnings('ignore')

class ARIMAAnalysis:
    """
    ARIMA时间序列分析类，用于处理股票数据的分析和预测。
    """

    def __init__(self, symbol, api_key, base_path):
        """
        初始化分析对象。
        @param symbol: 股票代码 (e.g., 'AAPL')
        @param api_key: Financial Modeling Prep API密钥
        @param base_path: 结果保存的根目录
        """
        self.base_path = base_path
        self.symbol = symbol
        os.makedirs(base_path, exist_ok=True)
        start_time = time.time()
        self.data = self.get_stock_data(symbol, api_key)
        self.prepare_data()
        print(f"数据获取和预处理完成，耗时: {time.time() - start_time:.2f}秒")

    @lru_cache(maxsize=5)
    def get_stock_data(self, symbol, api_key):
        """
        从Financial Modeling Prep API获取股票历史数据。
        @return: 包含历史价格的DataFrame
        """
        base_url = f"https://financialmodelingprep.com/api/v3/historical-price-full/{symbol}"
        params = {"apikey": api_key, "from": "2021-01-01", "to": "2024-12-31"}

        try:
            response = requests.get(base_url, params=params, timeout=10)
            if response.status_code == 200:
                data = response.json()
                df = pd.DataFrame(data['historical'])
                df['date'] = pd.to_datetime(df['date'])
                df = df.sort_values('date')
                if df.empty:
                    raise Exception(f"获取到的{symbol}数据为空")
                missing_values = df.isnull().sum()
                if missing_values.any():
                    print(f"警告: 数据中存在缺失值: {missing_values[missing_values > 0]}")
                    df = df.fillna(method='ffill')
                return df
            else:
                raise Exception(f"API请求失败，状态码: {response.status_code}")
        except requests.exceptions.RequestException as e:
            raise Exception(f"网络请求错误: {e}")

    def prepare_data(self):
        """
        数据预处理，包括设置日期索引和绘制原始数据图。
        """
        self.data.set_index('date', inplace=True)
        self.data = self.data.sort_index()

        plt.figure(figsize=(12, 6))
        plt.plot(self.data.index, self.data['adjClose'], label='调整后收盘价')
        plt.title(f'{self.symbol} 股票价格时间序列 (2021-2024)')
        plt.xlabel('日期')
        plt.ylabel('价格 (USD)')
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/original_series.png', dpi=300)
        plt.close()

        self.diff_data = pd.DataFrame()
        self.diff_data['adjClose_diff'] = self.data['adjClose'].diff()
        self.diff_data = self.diff_data.dropna()

        plt.figure(figsize=(12, 6))
        plt.plot(self.diff_data.index, self.diff_data['adjClose_diff'], label='一阶差分', color='orange')
        plt.title(f'{self.symbol} 股票价格一阶差分 (2021-2024)')
        plt.xlabel('日期')
        plt.ylabel('差分值')
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/differenced_series.png', dpi=300)
        plt.close()

        self.diff2_data = pd.DataFrame()
        self.diff2_data['adjClose_diff2'] = self.diff_data['adjClose_diff'].diff()
        self.diff2_data = self.diff2_data.dropna()

        plt.figure(figsize=(12, 6))
        plt.plot(self.diff2_data.index, self.diff2_data['adjClose_diff2'], label='二阶差分', color='green')
        plt.title(f'{self.symbol} 股票价格二阶差分 (2021-2024)')
        plt.xlabel('日期')
        plt.ylabel('差分值')
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/second_differenced_series.png', dpi=300)
        plt.close()

    def adf_test(self):
        """
        进行ADF检验，评估序列平稳性。
        @return: ADF检验结果DataFrame和推荐的差分阶数
        """
        result_original = adfuller(self.data['adjClose'].dropna())
        result_diff = adfuller(self.diff_data['adjClose_diff'].dropna())
        result_diff2 = adfuller(self.diff2_data['adjClose_diff2'].dropna())

        results_df = pd.DataFrame({
            'Series': ['原始序列', '一阶差分', '二阶差分'],
            'ADF统计量': [result_original[0], result_diff[0], result_diff2[0]],
            'p值': [result_original[1], result_diff[1], result_diff2[1]],
            '临界值(1%)': [result_original[4]['1%'], result_diff[4]['1%'], result_diff2[4]['1%']],
            '临界值(5%)': [result_original[4]['5%'], result_diff[4]['5%'], result_diff2[4]['5%']],
            '临界值(10%)': [result_original[4]['10%'], result_diff[4]['10%'], result_diff2[4]['10%']]
        })

        fig, ax = plt.subplots(figsize=(10, 6))
        bar_width = 0.25
        index = np.arange(3)
        plt.bar(index, results_df['ADF统计量'], bar_width, label='ADF统计量', color='skyblue')
        plt.bar(index + bar_width, results_df['临界值(5%)'], bar_width, label='5%临界值', color='lightcoral')
        plt.bar(index + 2 * bar_width, results_df['p值'], bar_width, label='p值', color='lightgreen')
        plt.xlabel('序列类型')
        plt.ylabel('值')
        plt.title('ADF检验结果 (2021-2024)')
        plt.xticks(index + bar_width, results_df['Series'])
        plt.legend()
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/adf_test_results.png', dpi=300)
        plt.close()

        print("\nADF检验结果:")
        for i, row in results_df.iterrows():
            is_stationary = row['ADF统计量'] < row['临界值(5%)']
            print(f"{row['Series']}:")
            print(f"  ADF统计量: {row['ADF统计量']:.4f}")
            print(f"  p值: {row['p值']:.4f}")
            print(f"  5%临界值: {row['临界值(5%)']:.4f}")
            print(f"  平稳性: {'平稳' if is_stationary else '非平稳'}")

        results_df.to_csv(f'{self.base_path}/adf_test_results.csv')

        recommended_d = 0
        for i, statistic in enumerate(results_df['ADF统计量']):
            if statistic < results_df['临界值(5%)'][i]:
                recommended_d = i
                break

        print(f"推荐差分阶数 (d): {recommended_d}")
        with open(f'{self.base_path}/recommended_d.txt', 'w') as f:
            f.write(f"推荐差分阶数 (d): {recommended_d}")

        return results_df, recommended_d

    def plot_acf_pacf(self, max_lags=40):
        """
        绘制ACF和PACF图以确定ARIMA参数。
        """
        series_data = [
            (self.data['adjClose'].dropna(), '原始序列'),
            (self.diff_data['adjClose_diff'], '一阶差分序列'),
            (self.diff2_data['adjClose_diff2'], '二阶差分序列')
        ]

        for series, name in series_data:
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
            plot_acf(series, ax=ax1, lags=max_lags, title=f'{name} - 自相关函数(ACF)')
            ax1.set_xlabel('滞后阶数')
            ax1.set_ylabel('自相关系数')
            ax1.grid(True, alpha=0.3)
            plot_pacf(series, ax=ax2, lags=max_lags, title=f'{name} - 偏自相关函数(PACF)')
            ax2.set_xlabel('滞后阶数')
            ax2.set_ylabel('偏自相关系数')
            ax2.grid(True, alpha=0.3)
            plt.tight_layout()
            plt.savefig(f'{self.base_path}/acf_pacf_{name}.png', dpi=300)
            plt.close()

        print("\nACF和PACF分析完成")

    def find_best_parameters(self, d=None):
        """
        使用auto_arima自动选择最优ARIMA参数。
        @return: 最优ARIMA参数元组 (p, d, q)
        """
        start_time = time.time()
        print("开始使用auto_arima寻找最优参数...")

        series = self.data['adjClose'] if d is None else self.diff_data['adjClose_diff'] if d == 1 else self.diff2_data['adjClose_diff2']
        model = auto_arima(series,
                           start_p=0, start_q=0,
                           max_p=5, max_q=5,
                           d=d,
                           m=1, start_P=0,
                           seasonal=False,
                           max_d=2 if d is None else d,
                           information_criterion='aic',
                           trace=True,
                           error_action='ignore',
                           suppress_warnings=True,
                           stepwise=True)

        print(f"\n最优ARIMA参数: {model.order}")
        print(f"AIC: {model.aic():.4f}")
        print(f"搜索耗时: {time.time() - start_time:.2f}秒")

        params = pd.DataFrame({'参数': ['p', 'd', 'q'], '值': [model.order[0], model.order[1], model.order[2]]})
        params.to_csv(f'{self.base_path}/best_parameters.csv')

        return model.order

    def test_multiple_models(self, recommended_d=None):
        """
        测试多种ARIMA参数组合，找到最佳模型。
        @return: 最佳模型参数元组 (p, d, q)
        """
        print("\n开始测试不同的ARIMA模型...")
        start_time = time.time()

        forecast_start = pd.to_datetime('2024-06-01')
        actual_7days = self.data['adjClose'][forecast_start:][:7]

        base_orders = [
            (1, recommended_d, 1), (1, recommended_d, 2),
            (2, recommended_d, 1), (2, recommended_d, 2),
            (3, recommended_d, 1), (2, recommended_d, 3)
        ] if recommended_d else [
            (1, 1, 1), (1, 1, 2), (2, 1, 1), (2, 1, 2),
            (1, 0, 1), (0, 1, 1)
        ]

        additional_orders = [(1, 2, 1), (2, 2, 1), (2, 0, 2), (3, 1, 2)]
        orders = list(set(base_orders + additional_orders))

        results = []
        plt.figure(figsize=(15, 8))
        plt.plot(actual_7days.index, actual_7days, 'ko-', label='实际值', linewidth=2)

        colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'cyan', 'magenta']

        def test_model(order):
            try:
                model = ARIMA(self.data['adjClose'][:forecast_start], order=order)
                model_fit = model.fit()
                forecast = model_fit.forecast(steps=len(actual_7days))
                min_length = min(len(actual_7days), len(forecast))
                actual_values = actual_7days[:min_length]
                forecast_values = forecast[:min_length]

                mse = mean_squared_error(actual_values, forecast_values)
                rmse = np.sqrt(mse)
                mae = mean_absolute_error(actual_values, forecast_values)
                mape_values = [abs((a - f) / a) * 100 for a, f in zip(actual_values, forecast_values) if a != 0]
                mape = np.mean(mape_values) if mape_values else float('nan')
                aic = model_fit.aic
                bic = model_fit.bic

                return {
                    'Order': order, 'MSE': mse, 'RMSE': rmse, 'MAE': mae,
                    'MAPE': mape, 'AIC': aic, 'BIC': bic, 'Forecast': forecast_values
                }
            except Exception as e:
                print(f"ARIMA{order}模型出错: {e}")
                return None

        with ThreadPoolExecutor(max_workers=min(4, len(orders))) as executor:
            model_results = list(executor.map(test_model, orders))

        model_results = [r for r in model_results if r is not None]
        results.extend(model_results)

        for i, result in enumerate(results):
            plt.plot(actual_7days.index, result['Forecast'], marker='o', linestyle='--',
                     color=colors[i % len(colors)], label=f'ARIMA{result["Order"]} (MSE={result["MSE"]:.4f})')

        plt.title('不同ARIMA模型的7天预测比较 (2021-2024数据)')
        plt.xlabel('日期')
        plt.ylabel('股票价格 (USD)')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.xticks(rotation=45)
        plt.figtext(0.5, 0.01, "图: 不同ARIMA模型的7天股票价格预测比较", ha="center", fontsize=10,
                    bbox={"facecolor": "white", "alpha": 0.8, "pad": 5})
        plt.savefig(f'{self.base_path}/model_comparison_7days.png', dpi=300, bbox_inches='tight')
        plt.close()

        df_results = pd.DataFrame(results)
        df_results['MSE_norm'] = (df_results['MSE'] - df_results['MSE'].min()) / (df_results['MSE'].max() - df_results['MSE'].min() + 1e-10)
        df_results['AIC_norm'] = (df_results['AIC'] - df_results['AIC'].min()) / (df_results['AIC'].max() - df_results['AIC'].min() + 1e-10)
        df_results['BIC_norm'] = (df_results['BIC'] - df_results['BIC'].min()) / (df_results['BIC'].max() - df_results['BIC'].min() + 1e-10)
        df_results['Score'] = 0.5 * df_results['MSE_norm'] + 0.25 * df_results['AIC_norm'] + 0.25 * df_results['BIC_norm']
        df_results = df_results.sort_values('Score').drop(['MSE_norm', 'AIC_norm', 'BIC_norm', 'Forecast'], axis=1)
        df_results.to_csv(f'{self.base_path}/model_comparison_7days.csv', index=False)

        heatmap_data = df_results[['Order'] + ['MSE', 'RMSE', 'MAE', 'MAPE', 'AIC', 'BIC', 'Score']].copy()
        heatmap_data['Order'] = heatmap_data['Order'].astype(str)
        heatmap_data.set_index('Order', inplace=True)
        for col in heatmap_data.columns:
            if heatmap_data[col].max() > 0:
                heatmap_data[col] = (heatmap_data[col] - heatmap_data[col].min()) / (heatmap_data[col].max() - heatmap_data[col].min() + 1e-10)
        plt.figure(figsize=(10, 8))
        sns.heatmap(heatmap_data, annot=True, cmap='YlGnBu', fmt='.2f')
        plt.title('ARIMA模型性能指标比较 (规范化值)')
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/model_metrics_heatmap.png', dpi=300)
        plt.close()

        fig, axes = plt.subplots(3, 1, figsize=(12, 10), sharex=True)
        top_5_models = df_results.head(5)
        for i, metric in enumerate(['MSE', 'AIC', 'BIC']):
            ax = axes[i]
            bars = ax.bar(top_5_models['Order'].astype(str), top_5_models[metric], color='skyblue')
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width() / 2., height + 0.01, f'{height:.2f}', ha='center', va='bottom')
            ax.set_title(f'{metric} 比较')
            ax.set_ylabel(metric)
            ax.grid(True, axis='y', alpha=0.3)
        plt.xlabel('ARIMA模型 (p,d,q)')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/top_models_metrics.png', dpi=300, bbox_inches='tight')
        plt.close()

        print("\n模型比较结果:")
        print(df_results.head())
        print(f"模型测试耗时: {time.time() - start_time:.2f}秒")
        best_order = tuple(df_results.iloc[0]['Order'])
        print(f"\n最佳模型: ARIMA{best_order}")

        return best_order

    def forecast_and_evaluate(self, steps, order):
        """
        进行预测并评估模型性能。
        @param steps: 预测步数 (e.g., 3, 7, 30)
        @param order: ARIMA模型参数 (p, d, q)
        @return: 预测结果、置信区间和评估指标
        """
        print(f"\n开始进行{steps}天预测 (ARIMA{order})...")
        forecast_start = pd.to_datetime('2024-06-01')

        # 分割训练集和测试集
        train_data = self.data['adjClose'][:forecast_start]
        test_data = self.data['adjClose'][forecast_start:][:steps]

        # 检查测试数据是否足够
        if len(test_data) < steps:
            print(f"警告：2024-06-01 之后的数据不足以进行 {steps} 天的预测，仅有 {len(test_data)} 天的数据。")
            if len(test_data) == 0:
                raise ValueError(f"无法进行 {steps} 天预测：测试数据为空。")

        # 训练模型
        model = ARIMA(train_data, order=order)
        model_fit = model.fit()

        # 预测
        forecast = model_fit.forecast(steps=steps)
        conf_int = model_fit.get_forecast(steps=steps).conf_int()

        # 确保长度匹配
        min_length = min(len(test_data), len(forecast), steps)
        actual = test_data[:min_length]
        forecast = pd.Series(forecast[:min_length].values, index=pd.RangeIndex(min_length))
        conf_int = conf_int.iloc[:min_length].reset_index(drop=True)

        # 如果实际数据不足，打印警告
        if len(actual) == 0:
            raise ValueError(f"实际数据为空，无法进行 {steps} 天的预测和评估。")

        # 计算评估指标
        mse = mean_squared_error(actual, forecast)
        rmse = np.sqrt(mse)
        mae = mean_absolute_error(actual, forecast)
        mape_values = [abs((a - f) / a) * 100 for a, f in zip(actual, forecast) if a != 0]
        mape = np.mean(mape_values) if mape_values else float('nan')

        if len(train_data) > 1:
            naive_errors = np.abs(np.diff(train_data))
            naive_mae = np.mean(naive_errors)
            mase = mae / naive_mae if naive_mae > 0 else float('nan')
        else:
            mase = float('nan')

        metrics = pd.DataFrame({
            '指标': ['MSE', 'RMSE', 'MAE', 'MAPE', 'MASE'],
            '值': [mse, rmse, mae, mape, mase]
        })

        print(f"\n{steps}天预测结果评估指标 (ARIMA{order}):")
        for i, metric in enumerate(metrics['指标']):
            print(f"{metric}: {metrics['值'][i]:.4f}" + ("%" if metric == "MAPE" else ""))

        metrics.to_csv(f'{self.base_path}/metrics_{steps}days.csv')

        # 保存预测结果，确保 Predicted 列有数据
        forecast_dates = pd.date_range(start=forecast_start, periods=min_length, freq='B')
        results_df = pd.DataFrame(index=forecast_dates)
        results_df['Actual'] = actual.values
        results_df['Predicted'] = forecast.values  # 确保 Predicted 列有值
        if isinstance(conf_int, pd.DataFrame):
            results_df['Lower_CI'] = conf_int.iloc[:, 0].values
            results_df['Upper_CI'] = conf_int.iloc[:, 1].values
        results_df['Error'] = actual.values - forecast.values
        results_df['Absolute_Error'] = np.abs(results_df['Error'])
        results_df['Percentage_Error'] = [abs((a - f) / a) * 100 if a != 0 else np.nan for a, f in zip(actual.values, forecast.values)]
        results_df.to_csv(f'{self.base_path}/forecast_results_{steps}days.csv')

        # 打印部分结果以便调试
        print(f"\n{steps}天预测结果预览（前5行）：")
        print(results_df.head())

        # 绘制预测结果
        plt.figure(figsize=(12, 6))
        plt.plot(results_df.index, results_df['Actual'], label='实际值', marker='o', color='blue')
        plt.plot(results_df.index, results_df['Predicted'], label='预测值', linestyle='--', marker='s', color='red')
        if 'Lower_CI' in results_df.columns and 'Upper_CI' in results_df.columns:
            plt.fill_between(results_df.index, results_df['Lower_CI'], results_df['Upper_CI'],
                             color='gray', alpha=0.2, label='95%置信区间')
        plt.title(f'{self.symbol} {steps}天股价预测 (ARIMA{order}) (2021-2024)')
        plt.xlabel('日期')
        plt.ylabel('价格 (USD)')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.xticks(rotation=45)
        error_text = f"MSE: {mse:.4f}\nRMSE: {rmse:.4f}\nMAE: {mae:.4f}\nMAPE: {mape:.2f}%"
        plt.annotate(error_text, xy=(0.02, 0.02), xycoords='axes fraction',
                     bbox=dict(boxstyle="round,pad=0.5", fc="white", alpha=0.8))
        plt.figtext(0.5, 0.01, f"图: {steps}天股价使用ARIMA{order}模型的预测结果",
                    ha="center", fontsize=10, bbox={"facecolor": "white", "alpha": 0.8, "pad": 5})
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/forecast_{steps}days.png', dpi=300, bbox_inches='tight')
        plt.close()

        # 绘制评估指标图
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6), gridspec_kw={'width_ratios': [3, 1]})
        error_metrics = metrics[metrics['指标'].isin(['MSE', 'RMSE', 'MAE', 'MAPE'])]
        colors = ['skyblue', 'lightgreen', 'lightcoral', 'orange']
        first_three = error_metrics[error_metrics['指标'].isin(['MSE', 'RMSE', 'MAE'])]
        bars1 = ax1.bar(first_three['指标'], pd.to_numeric(first_three['值'], errors='coerce'), color=colors[:3])
        for bar in bars1:
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width() / 2., height + 0.01, f'{height:.4f}', ha='center', va='bottom')
        ax1.set_title(f'误差指标 (MSE/RMSE/MAE)')
        ax1.set_xlabel('指标')
        ax1.set_ylabel('值')
        ax1.grid(True, axis='y', alpha=0.3)

        mape_data = error_metrics[error_metrics['指标'] == 'MAPE']
        bars2 = ax2.bar(mape_data['指标'], pd.to_numeric(mape_data['值'], errors='coerce'), color=colors[3])
        for bar in bars2:
            height = bar.get_height()
            ax2.text(bar.get_x() + bar.get_width() / 2., height + 0.01, f'{height:.2f}%', ha='center', va='bottom')
        ax2.axhline(y=10, color='black', linestyle='--', label='10% MAPE目标线')
        ax2.legend()
        ax2.set_title(f'误差指标 (MAPE)')
        ax2.set_xlabel('指标')
        ax2.set_ylabel('百分比 (%)')
        ax2.grid(True, axis='y', alpha=0.3)

        plt.suptitle(f'{steps}天预测的误差评估指标 (ARIMA{order})')
        plt.figtext(0.5, 0.01, f"图: {steps}天ARIMA{order}模型预测的误差指标",
                    ha="center", fontsize=10, bbox={"facecolor": "white", "alpha": 0.8, "pad": 5})
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/error_metrics_{steps}days.png', dpi=300, bbox_inches='tight')
        plt.close()

        # 残差分析
        self.residual_analysis(model_fit, steps, order, forecast, actual)

        return forecast, conf_int, metrics

    def residual_analysis(self, model_fit, steps, order, forecast, actual):
        """
        进行残差分析，基于预测的实际值和预测值。
        @param model_fit: 训练好的ARIMA模型
        @param steps: 预测步数
        @param order: ARIMA模型参数
        @param forecast: 预测值
        @param actual: 实际值
        """
        # 检查 actual 和 forecast 是否有数据
        if len(actual) == 0 or len(forecast) == 0:
            print(f"错误：{steps}天预测的 actual 或 forecast 数据为空，无法进行残差分析。")
            return

        # 确保数据类型正确
        if isinstance(forecast, pd.Series):
            forecast_values = forecast.values
        else:
            forecast_values = forecast

        if isinstance(actual, pd.Series):
            actual_values = actual.values
        else:
            actual_values = actual

        # 计算预测残差
        residuals = actual_values - forecast_values
        
        # 获取预测的日期范围
        if isinstance(actual, pd.Series):
            forecast_dates = actual.index
        else:
            forecast_start = pd.to_datetime('2024-06-01')
            forecast_dates = pd.date_range(start=forecast_start, periods=len(residuals), freq='B')

        # 将残差转换为Series以便后续分析
        residuals = pd.Series(residuals, index=forecast_dates)

        # 检查残差是否为空
        if residuals.isna().all() or len(residuals) == 0:
            print(f"错误：{steps}天预测的残差为空，无法生成残差分析图。")
            return

        # 1. 残差时间序列保存
        ts_df = pd.DataFrame({'日期': residuals.index.strftime('%Y-%m-%d'), '残差值': residuals.values})
        ts_df.to_csv(f'{self.base_path}/residuals_timeseries_{steps}days.csv', index=False)

        # 2. 残差分布保存（原始残差值即可）
        dist_df = pd.DataFrame({'残差值': residuals.values})
        dist_df.to_csv(f'{self.base_path}/residuals_distribution_{steps}days.csv', index=False)

        # 3. 残差QQ图数据保存
        qq = stats.probplot(residuals.values, dist="norm")
        qq_df = pd.DataFrame({'理论分位数': qq[0][0], '实际分位数': qq[0][1]})
        qq_df.to_csv(f'{self.base_path}/residuals_qq_{steps}days.csv', index=False)

        # 4. 残差ACF保存
        acf_vals = acf(residuals.values, nlags=min(40, len(residuals)-1), fft=False)
        acf_df = pd.DataFrame({'滞后阶数': range(len(acf_vals)), '自相关系数': acf_vals})
        acf_df.to_csv(f'{self.base_path}/residuals_acf_{steps}days.csv', index=False)

        print(f"已保存{steps}天预测的残差分析csv文件。")

        # 以下为原有绘图和统计部分
        print(f"\n{steps}天预测的残差基本信息:")
        print(f"残差数量: {len(residuals)}")
        print(f"残差范围: [{residuals.min():.4f}, {residuals.max():.4f}]")
        print(f"残差均值: {residuals.mean():.4f}")
        print(f"残差标准差: {residuals.std():.4f}")

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))

        # 残差时间序列图
        ax1.plot(forecast_dates, residuals.values, 'b-', label='残差')
        ax1.set_title('残差时间序列')
        ax1.set_xlabel('日期')
        ax1.set_ylabel('残差值')
        ax1.grid(True)
        ax1.legend()
        plt.setp(ax1.xaxis.get_majorticklabels(), rotation=45)

        # 残差直方图
        sns.histplot(residuals.values, ax=ax2, kde=True)
        ax2.set_title('残差分布')
        ax2.set_xlabel('残差值')
        ax2.set_ylabel('频数')

        # 残差QQ图
        stats.probplot(residuals.values, dist="norm", plot=ax3)
        ax3.set_title('残差Q-Q图')

        # 残差自相关图
        plot_acf(residuals.values, ax=ax4, lags=min(40, len(residuals)-1))
        ax4.set_title('残差自相关函数(ACF)')
        ax4.set_xlabel('滞后阶数')
        ax4.set_ylabel('自相关系数')

        plt.suptitle(f'{steps}天预测的残差分析 (ARIMA{order})', y=1.02)
        plt.tight_layout()
        plt.savefig(f'{self.base_path}/residuals_analysis_{steps}days.png', dpi=300, bbox_inches='tight')
        plt.close()

        # 输出残差统计信息
        residuals_stats = {
            '均值': np.mean(residuals),
            '标准差': np.std(residuals),
            '偏度': stats.skew(residuals),
            '峰度': stats.kurtosis(residuals)
        }
        print(f"\n{steps}天预测残差统计信息:")
        for key, value in residuals_stats.items():
            print(f"{key}: {value:.4f}")

        # 保存残差统计信息到csv
        stats_df = pd.DataFrame(list(residuals_stats.items()), columns=['指标', '值'])
        stats_df.to_csv(f'{self.base_path}/residuals_stats_{steps}days.csv', index=False)

        # 进行Durbin-Watson检验
        dw_stat = durbin_watson(residuals)
        print(f"\nDurbin-Watson检验统计量: {dw_stat:.4f}")
        if dw_stat < 1.5:
            print("存在正自相关")
        elif dw_stat > 2.5:
            print("存在负自相关")
        else:
            print("残差相对独立")

    def set_plot_chinese(self):
        """
        设置图表支持中文显示。
        """
        try:
            plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'Heiti TC', 'PingFang HK', 'Microsoft YaHei', 'SimHei', 'DejaVu Sans']
        except:
            self.use_english = True
            print("警告：中文字体设置失败，使用英文标签")

    def get_title(self, chinese_text, english_text):
        """
        根据字体支持情况返回标题。
        """
        return english_text if hasattr(self, 'use_english') else chinese_text

    def generate_report(self, best_order, forecasts_results=None):
        """
        生成详细的HTML分析报告。
        @param best_order: 最佳ARIMA模型参数
        @param forecasts_results: 不同时间窗口的预测结果字典
        @return: 报告文件路径
        """
        print("\n开始生成分析报告...")
        report_dir = f"{self.base_path}/report"
        os.makedirs(report_dir, exist_ok=True)
        report_file = f"{report_dir}/{self.symbol}_ARIMA_Report.html"
        pdf_file = f"{report_dir}/{self.symbol}_ARIMA_Report.pdf"

        image_files = glob.glob(f"{self.base_path}/*.png")
        for img_file in image_files:
            img_name = os.path.basename(img_file)
            shutil.copy(img_file, f"{report_dir}/{img_name}")

        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>{self.symbol} ARIMA分析报告</title>
            <style>
                body {{ font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; color: #333; }}
                .container {{ max-width: 1200px; margin: 0 auto; }}
                h1 {{ text-align: center; border-bottom: 2px solid #3498db; padding-bottom: 10px; }}
                h2 {{ border-bottom: 1px solid #ddd; padding-bottom: 5px; margin-top: 30px; }}
                .section {{ margin: 30px 0; }}
                .image-container {{ text-align: center; margin: 20px 0; }}
                img {{ max-width: 100%; height: auto; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }}
                table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
                th, td {{ padding: 10px; border: 1px solid #ddd; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
                tr:nth-child(even) {{ background-color: #f9f9f9; }}
                .conclusion {{ background-color: #f8f9fa; padding: 15px; border-left: 4px solid #3498db; margin: 20px 0; }}
                .footer {{ text-align: center; margin-top: 40px; font-size: 0.9em; color: #777; border-top: 1px solid #ddd; padding-top: 20px; }}
                .explanation {{ background-color: #f1f9f1; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 0.9em; }}
                .model-info {{ background-color: #e8f4fc; padding: 15px; border-radius: 5px; margin: 15px 0; }}
                .chart-description {{ font-style: italic; color: #555; margin: 5px 0 15px 0; }}
                @page {{ margin: 1cm; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>{self.symbol} 股票 ARIMA 模型分析报告</h1>
                <div class="section">
                    <h2>1. 数据概览</h2>
                    <p>本报告分析了{self.symbol}股票从{self.data.index[0].strftime('%Y年%m月%d日')}至{self.data.index[-1].strftime('%Y年%m月%d日')}的历史数据。</p>
                    <p>数据点总数: {len(self.data)}</p>
                    <p>股价范围: ${self.data['adjClose'].min():.2f} - ${self.data['adjClose'].max():.2f}</p>
                    <p>平均股价: ${self.data['adjClose'].mean():.2f}</p>
                    <p>标准差: ${self.data['adjClose'].std():.2f}</p>
                    <p>交易日数量: {len(self.data)}</p>
                    <div class="model-info">
                        <h3>ARIMA模型简介</h3>
                        <p>ARIMA(自回归综合移动平均)模型是一种用于时间序列预测的统计模型，由三个部分组成：</p>
                        <ul>
                            <li><strong>AR(p)</strong>: 自回归部分</li>
                            <li><strong>I(d)</strong>: 综合部分，表示差分阶数</li>
                            <li><strong>MA(q)</strong>: 移动平均部分</li>
                        </ul>
                    </div>
                    <div class="image-container">
                        <img src="original_series.png" alt="原始股价时间序列">
                        <p>图1: {self.symbol}股票价格时间序列</p>
                        <div class="chart-description">此图展示了原始股价的变动趋势。</div>
                    </div>
                </div>
                <div class="section">
                    <h2>2. 平稳性分析</h2>
                    <div class="explanation">
                        <p><strong>为什么需要平稳性?</strong> ARIMA模型要求数据平稳。</p>
                    </div>
                    <div class="image-container">
                        <img src="differenced_series.png" alt="一阶差分序列">
                        <p>图2: {self.symbol}股票价格一阶差分</p>
                        <div class="chart-description">一阶差分序列表示相邻时间点变化。</div>
                    </div>
                    <div class="image-container">
                        <img src="adf_test_results.png" alt="ADF检验结果">
                        <p>图3: ADF检验结果</p>
                        <div class="chart-description">p值<0.05表示序列平稳。</div>
                    </div>
                    <h3>ADF检验结果</h3>
                    <table>
                        <tr><th>序列</th><th>ADF统计量</th><th>p值</th><th>5%临界值</th><th>平稳性</th></tr>
        """
        try:
            adf_results = pd.read_csv(f"{self.base_path}/adf_test_results.csv")
            for i, row in adf_results.iterrows():
                is_stationary = row['ADF统计量'] < row['临界值(5%)']
                html_content += f"""
                <tr>
                    <td>{row['Series']}</td>
                    <td>{row['ADF统计量']:.4f}</td>
                    <td>{row['p值']:.4f}</td>
                    <td>{row['临界值(5%)']:.4f}</td>
                    <td>{'平稳' if is_stationary else '非平稳'}</td>
                </tr>
                """
        except:
            html_content += "<tr><td colspan='5'>无法加载ADF检验结果</td></tr>"
        html_content += """
                    </table>
                    <div class="explanation">
                        <p><strong>如何解读ADF检验结果:</strong></p>
                        <ul><li>p值 < 0.05: 序列平稳</li><li>ADF统计量 < 临界值: 序列平稳</li></ul>
                    </div>
                </div>
                <div class="section">
                    <h2>3. ACF和PACF分析</h2>
                    <div class="explanation">
                        <p><strong>ACF和PACF的作用:</strong> 用于确定p和q参数。</p>
                    </div>
                    <div class="image-container">
                        <img src="acf_pacf_一阶差分序列.png" alt="一阶差分序列的ACF和PACF">
                        <p>图4: 一阶差分序列的ACF和PACF图</p>
                        <div class="chart-description">蓝色阴影表示95%置信区间。</div>
                    </div>
                </div>
                <div class="section">
                    <h2>4. 模型选择</h2>
        """
        try:
            models_results = pd.read_csv(f"{self.base_path}/model_comparison_7days.csv")
            html_content += f"""
                    <p>共测试了{len(models_results)}个ARIMA模型参数组合。</p>
                    <div class="explanation">
                        <p><strong>评估指标说明:</strong></p>
                        <ul><li><strong>MAPE:</strong> 预测误差百分比</li><li><strong>MSE:</strong> 均方误差</li></ul>
                    </div>
                    <div class="image-container">
                        <img src="model_metrics_heatmap.png" alt="模型性能热力图">
                        <p>图5: ARIMA模型性能指标比较</p>
                        <div class="chart-description">颜色越深表示性能越好。</div>
                    </div>
                    <h3>前5个表现最好的模型</h3>
                    <table>
                        <tr><th>模型</th><th>MAPE (%)</th><th>MSE</th><th>RMSE</th><th>MAE</th><th>AIC</th><th>BIC</th></tr>
            """
            low_mape_models = models_results[models_results['MAPE'] < 10].sort_values('MSE')
            display_models = low_mape_models.head(5) if len(low_mape_models) > 0 else models_results.sort_values('MAPE').head(5)
            best_model_note = "MAPE < 10%且MSE最小" if len(low_mape_models) > 0 else "MAPE最小"
            for i, row in display_models.iterrows():
                order_str = str(tuple(row['Order'])) if isinstance(row['Order'], (list, tuple)) else row['Order']
                html_content += f"""
                <tr>
                    <td>ARIMA{order_str}</td>
                    <td>{row['MAPE']:.2f}</td>
                    <td>{row['MSE']:.4f}</td>
                    <td>{row['RMSE']:.4f}</td>
                    <td>{row['MAE']:.4f}</td>
                    <td>{row['AIC']:.2f}</td>
                    <td>{row['BIC']:.2f}</td>
                </tr>
                """
            html_content += f"""
                    </table>
                    <div class="model-info">
                        <p><strong>最佳模型:</strong> ARIMA{best_order} (选择标准: {best_model_note})</p>
                        <p><strong>模型解释:</strong> ARIMA{best_order} 表示:</p>
                        <ul><li>p = {best_order[0]}: 自回归项阶数</li><li>d = {best_order[1]}: 差分阶数</li><li>q = {best_order[2]}: 移动平均项阶数</li></ul>
                    </div>
            """
        except:
            html_content += "<p>无法加载模型比较结果</p>"
        html_content += """
                </div>
                <div class="section">
                    <h2>5. 预测结果</h2>
        """
        if forecasts_results:
            for steps, (forecast, conf_int, metrics) in forecasts_results.items():
                html_content += f"""
                    <h3>{steps}天预测</h3>
                    <div class="image-container">
                        <img src="forecast_{steps}days.png" alt="{steps}天预测">
                        <p>图6: {steps}天预测结果</p>
                        <div class="chart-description">蓝色线表示历史数据，红色线表示预测值，阴影区域表示置信区间。</div>
                    </div>
                    <h4>预测精度评估指标</h4>
                    <table>
                        <tr><th>指标</th><th>值</th><th>说明</th></tr>
                """
                metrics_explanations = {
                    'MSE': '平均平方误差', 'RMSE': '均方根误差', 'MAE': '平均绝对误差',
                    'MAPE': '平均绝对百分比误差', 'MASE': '平均绝对缩放误差'
                }
                for i, row in metrics.iterrows():
                    suffix = '%' if row['指标'] == 'MAPE' else ''
                    explanation = metrics_explanations.get(row['指标'], '')
                    html_content += f"""
                    <tr><td>{row['指标']}</td><td>{row['值']:.4f}{suffix}</td><td>{explanation}</td></tr>
                    """
                html_content += """
                    </table>
                """
        else:
            for steps in [3, 7, 30]:
                try:
                    metrics = pd.read_csv(f"{self.base_path}/metrics_{steps}days.csv")
                    html_content += f"""
                        <h3>{steps}天预测</h3>
                        <div class="image-container">
                            <img src="forecast_{steps}days.png" alt="{steps}天预测">
                            <p>图6: {steps}天预测结果</p>
                            <div class="chart-description">蓝色线表示历史数据，红色线表示预测值，阴影区域表示置信区间。</div>
                        </div>
                        <h4>预测精度评估指标</h4>
                        <table>
                            <tr><th>指标</th><th>值</th><th>说明</th></tr>
                    """
                    metrics_explanations = {
                        'MSE': '平均平方误差', 'RMSE': '均方根误差', 'MAE': '平均绝对误差',
                        'MAPE': '平均绝对百分比误差', 'MASE': '平均绝对缩放误差'
                    }
                    for i, row in metrics.iterrows():
                        suffix = '%' if row['指标'] == 'MAPE' else ''
                        explanation = metrics_explanations.get(row['指标'], '')
                        html_content += f"""
                        <tr><td>{row['指标']}</td><td>{row['值']:.4f}{suffix}</td><td>{explanation}</td></tr>
                        """
                    html_content += """
                        </table>
                    """
                except:
                    html_content += f"<p>没有找到{steps}天预测的结果</p>"

        html_content += """
                    <h3>残差分析</h3>
                    <div class="image-container">
                        <img src="residuals_analysis_7days.png" alt="残差分析">
                        <p>图7: 模型残差分析</p>
                        <div class="chart-description">残差分析评估模型拟合充分性，理想残差应为白噪声。</div>
                    </div>
                    <div class="explanation">
                        <p><strong>残差分析解读:</strong></p>
                        <ul><li>QQ图: 评估残差正态性</li><li>残差自相关: 检验残差独立性</li><li>残差分布: 均值接近0</li></ul>
                    </div>
                </div>
                <div class="section">
                    <h2>6. 结论</h2>
                    <div class="conclusion">
                        <p>基于对{self.symbol}股票的ARIMA模型分析，我们得出结论:</p>
                        <p>1. 数据平稳性: 原始序列不平稳，一阶差分后满足平稳性。</p>
                        <p>2. 最优模型: ARIMA{best_order}。</p>
        """
        mape_3d, mape_7d, mape_30d = None, None, None
        try: mape_3d = pd.read_csv(f"{self.base_path}/metrics_3days.csv")['值'][3]
        except: pass
        try: mape_7d = pd.read_csv(f"{self.base_path}/metrics_7days.csv")['值'][3]
        except: pass
        try: mape_30d = pd.read_csv(f"{self.base_path}/metrics_30days.csv")['值'][3]
        except: pass

        if mape_3d: html_content += f"<p>3. 3天预测精度: MAPE = {mape_3d:.2f}% {'(优秀)' if mape_3d < 10 else '(可接受)' if mape_3d < 20 else '(较差)'}</p>"
        if mape_7d: html_content += f"<p>4. 7天预测精度: MAPE = {mape_7d:.2f}% {'(优秀)' if mape_7d < 10 else '(可接受)' if mape_7d < 20 else '(较差)'}</p>"
        if mape_30d: html_content += f"<p>5. 30天预测精度: MAPE = {mape_30d:.2f}% {'(优秀)' if mape_30d < 10 else '(可接受)' if mape_30d < 20 else '(较差)'}</p>"

        overall_rating = "模型预测精度较高，适合短期和中期预测。" if mape_7d and mape_7d < 10 else \
                         "模型预测精度一般，可用于短期参考，中长期谨慎。" if mape_7d and mape_7d < 20 else \
                         "模型预测精度较低，建议结合其他分析。"
        html_content += f"""
                    <p>6. 总体评价: {overall_rating}</p>
                    <p>7. 模型应用建议:</p>
                    <ul><li>短期预测: 可作为交易参考</li><li>中长期预测: 结合更多因素</li><li>局限性: 无法捕捉非线性动态</li></ul>
                    <p>8. 未来改进方向:</p>
                    <ul><li>结合LSTM/GRU模型</li><li>加入交易量等特征</li><li>集成多模型预测</li></ul>
                </div>
            </div>
            <div class="footer">
                <p>本报告由ARIMA分析工具自动生成 | 生成日期: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                <p>© 2024 ARIMA股票分析系统</p>
            </div>
        </div>
        </body>
        </html>
        """

        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
        print(f"HTML分析报告已生成：{report_file}")

        try:
            weasyprint_spec = importlib.util.find_spec("weasyprint")
            if weasyprint_spec is None:
                print("未安装weasyprint库，无法生成PDF报告。请运行: pip install weasyprint")
                return report_file

            from weasyprint import HTML
            import tempfile
            temp_dir = tempfile.mkdtemp()
            temp_html = os.path.join(temp_dir, "temp_report.html")
            updated_html = html_content.replace('src="', f'src="{report_dir}/')
            with open(temp_html, 'w', encoding='utf-8') as f:
                f.write(updated_html)
            HTML(temp_html).write_pdf(pdf_file)
            print(f"PDF分析报告已生成：{pdf_file}")
            os.remove(temp_html)
            os.rmdir(temp_dir)
        except Exception as e:
            print(f"生成PDF失败: {str(e)}。将只生成HTML报告。")

        return report_file

def main():
    """
    主函数，运行整个分析流程。
    """
    base_path = '/Users/quyou/Desktop/毕业设计/ARIMA应用方向/AAPL_2021_2024'
    api_key = "qhylk6wN8OUWTgmLddldoMRPCo59NmBU"
    symbol = "AAPL"

    try:
        analysis = ARIMAAnalysis(symbol, api_key, base_path)
        print("数据获取和预处理完成")

        # 打印数据范围以便调试
        print(f"数据日期范围：{analysis.data.index.min()} 至 {analysis.data.index.max()}")
        print(f"2024-06-01 之后的数据点数：{len(analysis.data['adjClose'][pd.to_datetime('2024-06-01'):])}\n")

        adf_results, recommended_d = analysis.adf_test()
        print("\nADF检验结果:")
        print(adf_results)

        if recommended_d < 1:
            print("ADF检验推荐的差分阶数小于1，强制使用d=1")
            recommended_d = 1

        analysis.plot_acf_pacf()
        print("\nACF和PACF分析完成")

        print("\n开始测试不同的ARIMA模型...")
        best_order = analysis.test_multiple_models(recommended_d)

        forecasts_results = {}
        for steps in [3, 7, 30]:
            try:
                forecast, conf_int, metrics = analysis.forecast_and_evaluate(steps, best_order)
                forecasts_results[steps] = (forecast, conf_int, metrics)

                mape_value = metrics[metrics['指标'] == 'MAPE']['值'].values[0]
                if mape_value > 10:
                    print(f"\n{steps}天预测的MAPE > 10%，尝试其他模型参数组合...")
                    additional_orders = [
                        (4, max(1, recommended_d), 2), (4, max(1, recommended_d), 3),
                        (5, max(1, recommended_d), 2), (3, max(1, recommended_d), 4),
                        (2, max(1, recommended_d + 1), 2), (3, max(1, recommended_d + 1), 1)
                    ]
                    best_mape = mape_value
                    best_alternative_order = best_order
                    for order in additional_orders:
                        try:
                            model = ARIMA(analysis.data['adjClose'][:pd.to_datetime('2024-06-01')], order=order)
                            model_fit = model.fit()
                            alt_forecast = model_fit.forecast(steps=steps)
                            actual = analysis.data['adjClose'][pd.to_datetime('2024-06-01'):][:steps]
                            min_length = min(len(actual), len(alt_forecast))
                            actual = actual[:min_length]
                            alt_forecast = alt_forecast[:min_length]
                            alt_mape_values = [abs((a - f) / a) * 100 for a, f in zip(actual, alt_forecast) if a != 0]
                            alt_mape = np.mean(alt_mape_values) if alt_mape_values else float('nan')
                            print(f"ARIMA{order} MAPE: {alt_mape:.2f}%")
                            if alt_mape < best_mape:
                                best_mape = alt_mape
                                best_alternative_order = order
                                if alt_mape < 10:
                                    print(f"找到MAPE < 10%的模型: ARIMA{order} (MAPE: {alt_mape:.2f}%)")
                                    break
                        except Exception as e:
                            print(f"测试ARIMA{order}失败: {e}")
                    if best_alternative_order != best_order:
                        print(f"\n对于{steps}天预测，发现更好的模型: ARIMA{best_alternative_order} (MAPE: {best_mape:.2f}%)")
                        forecast, conf_int, metrics = analysis.forecast_and_evaluate(steps, best_alternative_order)
                        forecasts_results[steps] = (forecast, conf_int, metrics)
            except ValueError as e:
                print(f"{steps}天预测失败：{str(e)}")
                continue

        report_file = analysis.generate_report(best_order, forecasts_results)
        print(f"\n分析已完成，详细报告已保存至: {report_file}")

    except Exception as e:
        print(f"发生错误: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
